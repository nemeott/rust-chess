# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401, F403, F405

import builtins
import enum
import typing
__all__ = [
    "A1",
    "A2",
    "A3",
    "A4",
    "A5",
    "A6",
    "A7",
    "A8",
    "B1",
    "B2",
    "B3",
    "B4",
    "B5",
    "B6",
    "B7",
    "B8",
    "BB_EMPTY",
    "BB_FILES",
    "BB_FILE_A",
    "BB_FILE_B",
    "BB_FILE_C",
    "BB_FILE_D",
    "BB_FILE_E",
    "BB_FILE_F",
    "BB_FILE_G",
    "BB_FILE_H",
    "BB_FULL",
    "BB_RANKS",
    "BB_RANK_1",
    "BB_RANK_2",
    "BB_RANK_3",
    "BB_RANK_4",
    "BB_RANK_5",
    "BB_RANK_6",
    "BB_RANK_7",
    "BB_RANK_8",
    "BISHOP",
    "BLACK",
    "BLACK_BISHOP",
    "BLACK_KING",
    "BLACK_KNIGHT",
    "BLACK_PAWN",
    "BLACK_QUEEN",
    "BLACK_ROOK",
    "Bitboard",
    "Board",
    "BoardStatus",
    "C1",
    "C2",
    "C3",
    "C4",
    "C5",
    "C6",
    "C7",
    "C8",
    "COLORS",
    "Color",
    "D1",
    "D2",
    "D3",
    "D4",
    "D5",
    "D6",
    "D7",
    "D8",
    "E1",
    "E2",
    "E3",
    "E4",
    "E5",
    "E6",
    "E7",
    "E8",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "G1",
    "G2",
    "G3",
    "G4",
    "G5",
    "G6",
    "G7",
    "G8",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "H7",
    "H8",
    "KING",
    "KNIGHT",
    "Move",
    "MoveGenerator",
    "PAWN",
    "PIECES",
    "PIECE_TYPES",
    "Piece",
    "PieceType",
    "QUEEN",
    "ROOK",
    "SQUARES",
    "Square",
    "WHITE",
    "WHITE_BISHOP",
    "WHITE_KING",
    "WHITE_KNIGHT",
    "WHITE_PAWN",
    "WHITE_QUEEN",
    "WHITE_ROOK",
]

A1: Square
A2: Square
A3: Square
A4: Square
A5: Square
A6: Square
A7: Square
A8: Square
B1: Square
B2: Square
B3: Square
B4: Square
B5: Square
B6: Square
B7: Square
B8: Square
BB_EMPTY: Bitboard
BB_FILES: builtins.list[Bitboard]
BB_FILE_A: Bitboard
BB_FILE_B: Bitboard
BB_FILE_C: Bitboard
BB_FILE_D: Bitboard
BB_FILE_E: Bitboard
BB_FILE_F: Bitboard
BB_FILE_G: Bitboard
BB_FILE_H: Bitboard
BB_FULL: Bitboard
BB_RANKS: builtins.list[Bitboard]
BB_RANK_1: Bitboard
BB_RANK_2: Bitboard
BB_RANK_3: Bitboard
BB_RANK_4: Bitboard
BB_RANK_5: Bitboard
BB_RANK_6: Bitboard
BB_RANK_7: Bitboard
BB_RANK_8: Bitboard
BISHOP: PieceType
BLACK: Color
BLACK_BISHOP: Piece
BLACK_KING: Piece
BLACK_KNIGHT: Piece
BLACK_PAWN: Piece
BLACK_QUEEN: Piece
BLACK_ROOK: Piece
C1: Square
C2: Square
C3: Square
C4: Square
C5: Square
C6: Square
C7: Square
C8: Square
COLORS: builtins.list[Color]
D1: Square
D2: Square
D3: Square
D4: Square
D5: Square
D6: Square
D7: Square
D8: Square
E1: Square
E2: Square
E3: Square
E4: Square
E5: Square
E6: Square
E7: Square
E8: Square
F1: Square
F2: Square
F3: Square
F4: Square
F5: Square
F6: Square
F7: Square
F8: Square
G1: Square
G2: Square
G3: Square
G4: Square
G5: Square
G6: Square
G7: Square
G8: Square
H1: Square
H2: Square
H3: Square
H4: Square
H5: Square
H6: Square
H7: Square
H8: Square
KING: PieceType
KNIGHT: PieceType
PAWN: PieceType
PIECES: builtins.list[Piece]
PIECE_TYPES: builtins.list[PieceType]
QUEEN: PieceType
ROOK: PieceType
SQUARES: builtins.list[Square]
WHITE: Color
WHITE_BISHOP: Piece
WHITE_KING: Piece
WHITE_KNIGHT: Piece
WHITE_PAWN: Piece
WHITE_QUEEN: Piece
WHITE_ROOK: Piece
@typing.final
class Bitboard:
    r"""
    Bitboard class.
    Represents a 64-bit unsigned integer.
    Each bit represents a square on the chessboard.
    The least-significant bit represents a1, and the most-significant bit represents h8.
    Supports bitwise operations and iteration.
    Also supports comparison and equality.
    """
    def __new__(cls, bitboard_or_square: typing.Any) -> Bitboard:
        r"""
        Create a new Bitboard from a 64-bit integer or a square
        """
    @staticmethod
    def from_square(square: Square) -> Bitboard:
        r"""
        Create a new Bitboard from a square
        """
    @staticmethod
    def from_uint(bitboard: builtins.int) -> Bitboard:
        r"""
        Create a new Bitboard from an unsigned 64-bit integer
        """
    def to_square(self) -> Square:
        r"""
        Convert the Bitboard to a square.
        This grabs the least-significant square.
        """
    def to_uint(self) -> builtins.int:
        r"""
        Convert the Bitboard to an unsigned 64-bit integer
        """
    def __int__(self) -> builtins.int:
        r"""
        Convert the Bitboard to an integer
        """
    def get_string(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        """
    def popcnt(self) -> builtins.int:
        r"""
        Count the number of squares in the Bitboard
        """
    def flip_vertical(self) -> Bitboard:
        r"""
        Flip a bitboard vertically.
        View it from the opponent's perspective.
        Useful for operations that rely on symmetry, like piece-square tables.
        """
    def __iter__(self) -> Bitboard:
        r"""
        Return an iterator of the bitboard
        """
    def __next__(self) -> typing.Optional[Square]:
        r"""
        Get the next square in the Bitboard.
        Removes the square from the Bitboard.
        """
    def __eq__(self, other: typing.Any) -> builtins.bool:
        r"""
        Equality comparison (self == other).
        """
    def __ne__(self, other: typing.Any) -> builtins.bool:
        r"""
        Inequality comparison (self != other).
        """
    def __lt__(self, other: typing.Any) -> builtins.bool:
        r"""
        Less than comparison (self < other).
        """
    def __le__(self, other: typing.Any) -> builtins.bool:
        r"""
        Less than or equal comparison (self <= other).
        """
    def __gt__(self, other: typing.Any) -> builtins.bool:
        r"""
        Greater than comparison (self > other).
        """
    def __ge__(self, other: typing.Any) -> builtins.bool:
        r"""
        Greater than or equal comparison (self >= other).
        """
    def __invert__(self) -> Bitboard:
        r"""
        Bitwise NOT operation
        """
    def __and__(self, other: typing.Any) -> Bitboard:
        r"""
        Bitwise AND operation (self & other).
        """
    def __rand__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected bitwise AND operation (other & self).
        """
    def __iand__(self, other: typing.Any) -> None:
        r"""
        In-place bitwise AND operation (self &= other).
        """
    def __or__(self, other: typing.Any) -> Bitboard:
        r"""
        Bitwise OR operation (self | other).
        """
    def __ror__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected bitwise OR operation (other | self).
        """
    def __ior__(self, other: typing.Any) -> None:
        r"""
        In-place bitwise OR operation (self |= other).
        """
    def __xor__(self, other: typing.Any) -> Bitboard:
        r"""
        Bitwise XOR operation (self ^ other).
        """
    def __rxor__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected bitwise XOR operation (other ^ self).
        """
    def __ixor__(self, other: typing.Any) -> None:
        r"""
        In-place bitwise XOR operation (self ^= other).
        """
    def __mul__(self, other: typing.Any) -> Bitboard:
        r"""
        Multiplication operation (self * other).
        """
    def __rmul__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected multiplication operation (other * self).
        """
    def __imul__(self, other: typing.Any) -> None:
        r"""
        In-place multiplication operation (self *= other).
        """
    def __lshift__(self, shift: builtins.int) -> Bitboard:
        r"""
        Left shift operation (self << shift).
        """
    def __rlshift__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected left shift operation (other << self)
        """
    def __ilshift__(self, shift: builtins.int) -> None:
        r"""
        In-place left shift operation (self <<= shift).
        """
    def __rshift__(self, shift: builtins.int) -> Bitboard:
        r"""
        Right shift operation (self >> shift).
        """
    def __rrshift__(self, other: typing.Any) -> Bitboard:
        r"""
        Reflected right shift operation (other >> self)
        """
    def __irshift__(self, shift: builtins.int) -> None:
        r"""
        In-place right shift operation (self >>= shift).
        """

@typing.final
class Board:
    r"""
    Board class.
    Represents the state of a chess board.
    """
    @property
    def halfmove_clock(self) -> builtins.int:
        r"""
        Get the halfmove clock.
        
        ```python
        >>> rust_chess.Board().halfmove_clock
        0
        ```
        """
    @property
    def fullmove_number(self) -> builtins.int:
        r"""
        Get the fullmove number.
        
        ```python
        >>> rust_chess.Board().fullmove_number
        1
        ```
        """
    @property
    def turn(self) -> Color:
        r"""
        Get the current player to move.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.turn
        True
        >>> print(board.turn)
        WHITE
        ```
        """
    @property
    def en_passant(self) -> typing.Optional[Square]:
        r"""
        Get the en passant square, otherwise None.
        
        ```python
        >>> rust_chess.Board().en_passant
        
        >>> rust_chess.Board().en_passant == None
        True
        >>> board = rust_chess.Board("rnbqkbnr/pp2p1pp/2p5/3pPp2/5P2/8/PPPP2PP/RNBQKBNR w KQkq f6 0 4")
        >>> board.en_passant
        f6
        ```
        """
    def __new__(cls, fen: typing.Optional[builtins.str] = None) -> Board:
        r"""
        Create a new board from a FEN string, otherwise default to the starting position.
        
        ```python
        >>> rust_chess.Board()
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        >>> rust_chess.Board("rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2")
        rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2
        ```
        """
    def get_fen(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> rust_chess.Board().get_fen()
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> print(rust_chess.Board())
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> print(rust_chess.Board())
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        ```
        """
    @staticmethod
    def from_fen(fen: builtins.str) -> Board:
        r"""
        Create a new board from a FEN string.
        
        ```python
        >>> rust_chess.Board.from_fen("rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2")
        rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2
        ```
        """
    def is_en_passant(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if a move is en passant.
        
        Assumes the move is legal.
        
        ```python
        >>> rust_chess.Board().is_en_passant(rust_chess.Move("e2e4"))
        False
        >>> board = rust_chess.Board("rnbqkbnr/pp2p1pp/2p5/3pPp2/5P2/8/PPPP2PP/RNBQKBNR w KQkq f6 0 4")
        >>> board.is_en_passant(rust_chess.Move("e5f6"))
        True
        ```
        """
    def is_capture(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if a move is a capture.
        
        Assumes the move is legal.
        
        ```python
        >>> board = rust_chess.Board()
        >>> board.is_capture(rust_chess.Move("e2e4"))
        False
        >>> board.make_move(rust_chess.Move("e2e4"))
        >>> board.make_move(rust_chess.Move("d7d5"))
        >>> board.is_capture(rust_chess.Move("e4d5"))
        True
        >>> ep_board = rust_chess.Board("rnbqkbnr/pp2p1pp/2p5/3pPp2/5P2/8/PPPP2PP/RNBQKBNR w KQkq f6 0 4")
        >>> ep_board.is_capture(rust_chess.Move("e5f6"))
        True
        ```
        """
    def get_piece_type_on(self, square: Square) -> typing.Optional[PieceType]:
        r"""
        Get the piece type on a square, otherwise None.
        Different than `get_piece_on` because it returns the piece type, which does not include color.
        
        ```python
        >>> rust_chess.Board().get_piece_type_on(rust_chess.A1)
        R
        >>> rust_chess.Board().get_piece_type_on(rust_chess.E8)
        K
        ```
        """
    def get_color_on(self, square: Square) -> typing.Optional[Color]:
        r"""
        Get the color of the piece on a square, otherwise None.
        
        ```python
        >>> rust_chess.Board().get_color_on(rust_chess.A1)
        True
        >>> print(rust_chess.Board().get_color_on(rust_chess.A1))
        WHITE
        >>> rust_chess.Board().get_color_on(rust_chess.E8)
        False
        ```
        """
    def get_piece_on(self, square: Square) -> typing.Optional[Piece]:
        r"""
        Get the piece on a square (color-inclusive), otherwise None.
        Different than `get_piece_on` because it returns the piece, which includes color.
        
        ```python
        >>> rust_chess.Board().get_piece_on(rust_chess.A1)
        R
        >>> rust_chess.Board().get_piece_on(rust_chess.E8)
        k
        ```
        """
    def get_king_square(self, color: Color) -> Square:
        r"""
        Get the king square of a color
        TODO:
        """
    def is_zeroing(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if a move is a capture or a pawn move.
        "Zeros" the halfmove clock (sets it to 0).
        
        Doesn't check legality.
        TODO:
        """
    def is_legal_move(self, chess_move: Move) -> builtins.bool:
        r"""
        Check if the move is legal (supposedly very slow according to the chess crate).
        Use this function for moves not generated by the move generator.
        `is_legal_quick` is faster for moves generated by the move generator.
        
        ```python
        >>> move = rust_chess.Move("e2e4")
        >>> rust_chess.Board().is_legal_move(move)
        True
        >>> move2 = rust_chess.Move("e2e5")
        >>> rust_chess.Board().is_legal_move(move2)
        False
        ```
        """
    def make_null_move_new(self) -> typing.Optional[Board]:
        r"""
        Make a null move onto a new board.
        Returns None if the current player is in check.
        
        ```python
        >>> board = rust_chess.Board()
        >>> print(board)
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        >>> new_board = board.make_null_move_new()
        >>> print(new_board)
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR b KQkq - 1 1
        
        >>> board = rust_chess.Board("rnbqkbnr/ppppp1pp/5p2/7Q/8/4P3/PPPP1PPP/RNB1KBNR b KQkq - 1 2")
        >>> new_board = board.make_null_move_new()
        >>> print(new_board)
        None
        ```
        """
    def make_move_new(self, chess_move: Move, check_legality: builtins.bool = True) -> Board:
        r"""
        Make a move onto a new board
        """
    def make_move(self, chess_move: Move, check_legality: builtins.bool = True) -> None:
        r"""
        Make a move on the current board
        """
    def get_pinned_bitboard(self) -> Bitboard:
        r"""
        Get the bitboard of the side to move's pinned pieces
        """
    def get_checkers_bitboard(self) -> Bitboard:
        r"""
        Get the bitboard of the pieces putting the side to move in check
        """
    def get_color_bitboard(self, color: Color) -> Bitboard:
        r"""
        Get the bitboard of all the pieces of a certain color
        """
    def get_piece_type_bitboard(self, piece_type: PieceType) -> Bitboard:
        r"""
        Get the bitboard of all the pieces of a certain type
        """
    def get_piece_bitboard(self, piece: Piece) -> Bitboard:
        r"""
        Get the bitboard of all the pieces of a certain color and type
        """
    def get_all_bitboard(self) -> Bitboard:
        r"""
        Get the bitboard of all the pieces
        """
    def remove_move(self, chess_move: Move) -> None:
        r"""
        Remove a move from the move generator.
        Prevents the move from being generated.
        Useful if you already have a certain move and don't need to generate it again.
        
        FIXME
        """
    def reset_move_generator(self) -> None:
        r"""
        Reset the move generator for the current board
        """
    def generate_next_move(self) -> typing.Optional[Move]:
        r"""
        Get the next remaining move in the generator.
        Updates the move generator to the next move.
        Unless the mask is set, this will return the next legal move by default.
        """
    def generate_legal_moves(self) -> MoveGenerator:
        r"""
        Generate the next remaining legal moves for the current board.
        Exhausts the move generator if fully iterated over.
        Updates the move generator.
        """
    def generate_legal_captures(self) -> MoveGenerator:
        r"""
        Generate the next remaining legal captures for the current board.
        Exhausts the move generator if fully iterated over.
        Updates the move generator.
        """
    def is_fifty_moves(self) -> builtins.bool:
        r"""
        Checks if the halfmoves since the last pawn move or capture is >= 100
        and the game is ongoing (not checkmate or stalemate).
        
        This is a claimable draw according to FIDE rules.
        
        ```python
        >>> rust_chess.Board().is_fifty_moves()
        False
        >>> rust_chess.Board("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 100 1").is_fifty_moves()
        True
        ```
        """
    def is_seventy_five_moves(self) -> builtins.bool:
        r"""
        Checks if the halfmoves since the last pawn move or capture is >= 150
        and the game is ongoing (not checkmate or stalemate).
        
        This is an automatic draw according to FIDE rules.
        
        ```python
        >>> rust_chess.Board().is_seventy_five_moves()
        False
        >>> rust_chess.Board("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 150 1").is_seventy_five_moves()
        True
        ```
        """
    def is_insufficient_material(self) -> builtins.bool:
        r"""
        Checks if the side to move has insufficient material to checkmate the opponent.
        The cases where this is true are:
            1. K vs K
            2. K vs K + N
            3. K vs K + B
            4. K + B vs K + B with the bishops on the same color.
        
        ```python
        >>> rust_chess.Board().is_insufficient_material()
        False
        >>> rust_chess.Board("4k3/8/8/8/8/8/8/4K3 w - - 0 1").is_insufficient_material() # K vs K
        True
        >>> rust_chess.Board("4k3/8/8/8/5N2/8/8/4K3 w - - 0 1").is_insufficient_material() # K vs K + N
        True
        >>> rust_chess.Board("4k3/8/8/8/5B2/8/8/4K3 w - - 0 1").is_insufficient_material() # K vs K + B
        True
        >>> rust_chess.Board("4k3/8/8/5b2/5B2/8/8/4K3 w - - 0 1").is_insufficient_material() # K + B vs K + B different color
        False
        >>> rust_chess.Board("4k3/8/5b2/8/5B2/8/8/4K3 w - - 0 1").is_insufficient_material() # K + B vs K + B same color
        True
        ```
        """
    def is_threefold_repetition(self) -> builtins.bool:
        r"""
        Checks if the game is in a threefold repetition.
        
        This is a claimable draw according to FIDE rules.
        TODO: Currently not implementable due to no storage of past moves
        """
    def is_fivefold_repetition(self) -> builtins.bool:
        r"""
        Checks if the game is in a fivefold repetition.
        
        This is an automatic draw according to FIDE rules.
        TODO: Currently not implementable due to no storage of past moves
        """
    def is_check(self) -> builtins.bool:
        r"""
        Checks if the side to move is in check.
        
        ```python
        >>> rust_chess.Board().is_check()
        False
        >>> rust_chess.Board("rnb1kbnr/pppp1ppp/4p3/8/6Pq/5P2/PPPPP2P/RNBQKBNR w KQkq - 1 3").is_check()
        True
        ```
        """
    def is_stalemate(self) -> builtins.bool:
        r"""
        Checks if the side to move is in stalemate
        """
    def is_checkmate(self) -> builtins.bool:
        r"""
        Checks if the side to move is in checkmate
        """
    def get_status(self) -> BoardStatus:
        r"""
        Get the status of the board (ongoing, draw, or game-ending).
        """

@typing.final
class Color:
    r"""
    Color enum class.
    White is True, Black is False.
    
    ```python
    >>> color = rust_chess.WHITE
    
    >>> color
    True
    >>> print(color)
    WHITE
    >>> color == rust_chess.BLACK
    False
    >>> color == (not rust_chess.BLACK)
    True
    ```
    """
    def get_string(self) -> builtins.str:
        r"""
        Get the color as a string.
        
        ```python
        >>> rust_chess.WHITE.get_string()
        'WHITE'
        >>> rust_chess.BLACK.get_string()
        'BLACK'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the color as a string.
        
        ```python
        >>> print(rust_chess.WHITE)
        WHITE
        >>> print(rust_chess.BLACK)
        BLACK
        ```
        """
    def __bool__(self) -> builtins.bool:
        r"""
        Get the color as a boolean.
        
        ```python
        >>> bool(rust_chess.WHITE)
        True
        >>> bool(rust_chess.BLACK)
        False
        ```
        """
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str:
        r"""
        Get the color as a boolean string.
        
        ```python
        >>> rust_chess.WHITE
        True
        >>> rust_chess.BLACK
        False
        ```
        """
    def __eq__(self, other: typing.Any) -> builtins.bool:
        r"""
        Compare the color to another color or boolean.
        
        ```python
        >>> rust_chess.WHITE == rust_chess.BLACK
        False
        >>> rust_chess.WHITE == True
        True
        ```
        """

@typing.final
class Move:
    r"""
    Move class.
    Represents a chess move.
    The move is represented as a source square, destination square, and optional promotion piece.
    
    ```python
    >>> move = rust_chess.Move(rust_chess.A4, rust_chess.B1)
    >>> move
    Move(a4, b1, None)
    >>> print(move)
    a4b1
    >>> rust_chess.Move("a2a1q")
    Move(a2, a1, QUEEN)
    >>> move.get_uci() == rust_chess.Move.from_uci("a4b1")  # FIXME
    True
    >>> move.source
    a4
    >>> move.dest
    b1
    >>> move.promotion
    
    >>> move.promotion == None
    True
    ```
    """
    @property
    def source(self) -> Square:
        r"""
        Get the source square of the move.
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.source
        a2
        ```
        """
    @property
    def dest(self) -> Square:
        r"""
        Get the destination square of the move.
        
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.dest
        a4
        ```
        """
    @property
    def promotion(self) -> typing.Optional[PieceType]:
        r"""
        Get the promotion piece of the move, otherwise None.
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.promotion
        
        >>> move.promotion == None
        True
        >>> move = rust_chess.Move("g2g1q")
        >>> move.promotion
        Q
        ```
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, source_or_uci: typing.Any, dest: typing.Optional[Square] = None, promotion: typing.Optional[PieceType] = None) -> Move:
        r"""
        Create a new move from a source, destination, and optional promotion piece or UCI string.
        
        ```python
        >>> rust_chess.Move(rust_chess.A2, rust_chess.A4)
        (a2, a4, None)
        >>> rust_chess.Move("g2g1q")
        (g2, g1, QUEEN)
        ```
        """
    @staticmethod
    def from_uci(uci: builtins.str) -> Move:
        r"""
        Create a new move from a UCI string (e.g. "e2e4").
        
        ```python
        >>> rust_chess.Move.from_uci("e2e4")
        Move(e2, e4, None)
        ```
        """
    def get_uci(self) -> builtins.str:
        r"""
        Get the UCI string representation of the move (e.g. "e2e4").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.get_uci()
        'a2a4'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the UCI string representation of the move (e.g. "e2e4").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> print(move)
        a2a4
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the internal representation of the move (e.g. "Move(e2, e4, None)").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move
        Move(e2, e4, None)
        ```
        """

@typing.final
class MoveGenerator:
    r"""
    Move iterator class for generating legal moves.
    Not intended for direct use.
    Use the `Board` class methods for generating moves.
    """
    def __iter__(self) -> MoveGenerator:
        r"""
        Return an iterator of the generator
        """
    def __next__(self) -> typing.Optional[Move]:
        r"""
        Get the next move in the generator
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the type of the move generator
        """

@typing.final
class Piece:
    r"""
    Piece class.
    Represents a chess piece with a type and color.
    Uses the PieceType and Color classes.
    Supports comparison and equality.
    A white piece is considered less than a black piece of the same type.
    
    ```python
    TODO
    ```
    """
    @property
    def piece_type(self) -> PieceType:
        r"""
        Get the piece type of the piece
        """
    @property
    def color(self) -> Color:
        r"""
        Get the color of the piece
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, piece_type: PieceType, color_or_bool: typing.Any) -> Piece:
        r"""
        Create a new piece from a piece type and color
        """
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the piece (0-5)
        """
    def get_string(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        White is uppercase and black is lowercase.
        
        ```python
        >>> rust_chess.WHITE_PAWN.get_string()
        'P'
        >>> rust_chess.BLACK_PAWN.get_string()
        'p'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        White is uppercase and black is lowercase.
        
        ```python
        >>> print(rust_chess.WHITE_PAWN)
        P
        >>> print(rust_chess.BLACK_PAWN)
        p
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        White is uppercase and black is lowercase.
        
        ```python
        >>> rust_chess.WHITE_PAWN
        P
        >>> rust_chess.BLACK_PAWN
        p
        ```
        """
    def get_unicode(self) -> builtins.str:
        r"""
        Convert the piece to a unicode string.
        White is hollow and black is full.
        
        ```python
        >>> rust_chess.WHITE_PAWN.get_unicode()
        '♙'
        >>> rust_chess.BLACK_PAWN.get_unicode()
        '♟'
        ```
        """

@typing.final
class PieceType:
    r"""
    Piece type enum class.
    Represents the different types of chess pieces.
    Indexing starts at 0 (PAWN) and ends at 5 (KING).
    Supports comparison and equality.
    Does not include color.
    
    `rust_chess` has constants for each piece type (e.g. PAWN, KNIGHT, etc.).
    
    ```python
    >>> piece = rust_chess.PAWN
    
    >>> print(piece)
    P
    >>> piece == rust_chess.PAWN
    True
    >>> piece == rust_chess.KNIGHT
    False
    >>> piece.get_index()
    0
    >>> piece < rust_chess.KNIGHT
    True
    ```
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the piece.
        Ranges from 0 (PAWN) to 5 (KING).
        
        ```python
        >>> rust_chess.BISHOP.get_index()
        2
        ```
        """
    def __index__(self) -> builtins.int:
        r"""
        Allow the piece type to be used as an index.
        Returns the index of the piece.
        
        ```python
        >>> arr = [1, 2, 3, 4, 5, 6]
        >>> arr[rust_chess.BISHOP]
        3
        ```
        """
    def get_string(self, color: Color = True) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter by default.
        If using the optional color parameter, white is uppercase and black is lowercase.
        
        ```python
        >>> rust_chess.PAWN.get_string()
        'P'
        >>> rust_chess.PAWN.get_string(rust_chess.BLACK)
        'p'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter.
        
        ```python
        >>> print(rust_chess.PAWN)
        P
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter.
        
        ```python
        >>> rust_chess.PAWN
        P
        ```
        """
    def get_unicode(self, color: Color = True) -> builtins.str:
        r"""
        Convert the piece to a unicode string.
        Returns the hollow unicode piece by default.
        If using the optional color parameter, white is hollow and black is full.
        
        ```python
        >>> rust_chess.PAWN.get_unicode()
        '♙'
        >>> rust_chess.PAWN.get_unicode(rust_chess.BLACK)
        '♟'
        ```
        """

@typing.final
class Square:
    r"""
    Square class.
    Represents a square on the chessboard.
    The square is represented as an integer (0-63) or a string (e.g. "e4").
    Supports comparison and equality.
    
    rust-chess has constants for each square (e.g. A1, B2, etc.).
    
    ```python
    >>> square = rust_chess.Square(0)
    >>> square
    a1
    >>> print(square)
    a1
    >>> square == rust_chess.Square("a1")
    True
    >>> square == rust_chess.A1
    True
    >>> square.get_index()
    0
    >>> rust_chess.A4 == 24
    True
    >>> rust_chess.G4.get_rank()
    3
    >>> rust_chess.G4.get_file()
    6
    TODO
    ```
    """
    def __new__(cls, square_index_or_name: typing.Any) -> Square:
        r"""
        Creates a new square from an integer (0-63) or a string (e.g. "e4").
        
        ```python
        >>> rust_chess.Square(0)
        a1
        >>> rust_chess.Square("e4")
        e4
        ```
        """
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the square (0-63).
        Indexing starts at 0 (a1) and ends at 63 (h8).
        
        ```python
        >>> rust_chess.Square("e4").get_index()
        28
        ```
        """
    def __index__(self) -> builtins.int:
        r"""
        Get the index of the square as an integer for indexing.
        
        ```python
        >>> int(rust_chess.Square("e4"))
        28
        ```
        """
    def __int__(self) -> builtins.int:
        r"""
        Get the index of the square as an integer.
        
        ```python
        >>> arr = [1, 2, 3, 4, 5, 6]
        >>> arr[rust_chess.Square("a1")]
        1
        ```
        """
    def __hash__(self) -> builtins.int:
        r"""
        Hash the square based on its index.
        
        ```python
        >>> hash(rust_chess.E4)
        28
        ```
        """
    def flip(self) -> Square:
        r"""
        Flips a square (eg. A1 -> A8)
        """
    def to_bitboard(self) -> Bitboard:
        r"""
        Convert a square to a bitboard
        """
    @staticmethod
    def from_index(index: builtins.int) -> Square:
        r"""
        Create a new square from an index.
        Indexing starts at 0 (a1) and ends at 63 (h8).
        
        ```python
        >>> rust_chess.Square.from_index(0)
        a1
        ```
        """
    @staticmethod
    def from_rank_file(rank: builtins.int, file: builtins.int) -> Square:
        r"""
        Create a new square from rank and file.
        Rank and file are 0-indexed (0-7).
        
        ```python
        >>> rust_chess.Square.from_rank_file(0, 3)
        d1
        ```
        """
    @staticmethod
    def from_file_rank(file: builtins.int, rank: builtins.int) -> Square:
        r"""
        Create a new square from file and rank.
        File and rank are 0-indexed (0-7).
        
        ```python
        >>> rust_chess.Square.from_file_rank(3, 0)
        d1
        ```
        """
    def get_name(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4").
        
        ```python
        >>> rust_chess.E4.get_name()
        'e4'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4"),
        
        ```python
        >>> print(rust_chess.E4)
        e4
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4").
        
        ```python
        >>> rust_chess.E4
        e4
        ```
        """
    def get_color(self) -> Color:
        r"""
        Get the color of the square on the chessboard
        """
    @staticmethod
    def from_name(square_name: builtins.str) -> Square:
        r"""
        Create a new square from a name (e.g. "e4").
        Not really needed since you can use the square constants.
        Could also just call the constructor with the name string.
        
        ```python
        >>> rust_chess.Square.from_name("d2")
        d2
        ```
        """
    def __richcmp__(self, other: typing.Any, op: int) -> builtins.bool:
        r"""
        Compare the square to another square or integer.
        
        ```python
        >>> rust_chess.Square("d2") == rust_chess.D2
        True
        >>> rust_chess.Square("d2") == 11
        True
        >>> rust_chess.G6 > rust_chess.D3
        True
        >>> rust_chess.G6 <= 56
        True
        ```
        """
    def get_rank(self) -> builtins.int:
        r"""
        Get the rank of the square as an integer (0-7).
        
        ```python
        >>> rust_chess.E4.get_rank()
        3
        ```
        """
    def get_file(self) -> builtins.int:
        r"""
        Get the file of the square as an integer (0-7).
        
        ```python
        >>> rust_chess.E4.get_file()
        4
        ```
        """
    def up(self) -> typing.Optional[Square]:
        r"""
        Returns the square above, otherwise None.
        
        ```python
        >>> rust_chess.H5.up()
        h6
        ```
        """
    def down(self) -> typing.Optional[Square]:
        r"""
        Returns the square below, otherwise None.
        
        ```python
        >>> rust_chess.H5.down()
        h4
        ```
        """
    def left(self) -> typing.Optional[Square]:
        r"""
        Returns the square to the left, otherwise None.
        
        ```python
        >>> rust_chess.H5.left()
        g5
        ```
        """
    def right(self) -> typing.Optional[Square]:
        r"""
        Returns the square to the right, otherwise None
        
        ```python
        >>> rust_chess.H5.right()
        
        >>> rust_chess.H5.right() == None
        True
        ```
        """

@typing.final
class BoardStatus(enum.Enum):
    r"""
    Board status enum class.
    Represents the status of a chess board.
    The status can be one of the following:
        Ongoing, seventy-five moves, five-fold repetition, insufficient material, stalemate, or checkmate.
    Supports comparison and equality.
    """
    ONGOING = ...
    SEVENTY_FIVE_MOVES = ...
    FIVE_FOLD_REPETITION = ...
    INSUFFICIENT_MATERIAL = ...
    STALEMATE = ...
    CHECKMATE = ...

